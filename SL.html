<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SL</title><link rel="stylesheet" href="css/Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--allow-unsolved-metas</a> <a id="36" class="Symbol">#-}</a>
<a id="40" class="Comment">---------------------------</a>
<a id="68" class="Comment">-- ** Separation logic (SL)</a>

<a id="97" class="Keyword">module</a> <a id="104" href="SL.html" class="Module">SL</a> <a id="107" class="Keyword">where</a>

<a id="114" class="Keyword">open</a> <a id="119" class="Keyword">import</a> <a id="126" href="Prelude.Init.html" class="Module">Prelude.Init</a>
<a id="139" class="Keyword">open</a> <a id="144" href="Prelude.Init.html#5630" class="Module">L.Mem</a>
<a id="150" class="Keyword">open</a> <a id="155" class="Keyword">import</a> <a id="162" href="Prelude.DecEq.html" class="Module">Prelude.DecEq</a>
<a id="176" class="Keyword">open</a> <a id="181" class="Keyword">import</a> <a id="188" href="Prelude.Decidable.html" class="Module">Prelude.Decidable</a>
<a id="206" class="Keyword">open</a> <a id="211" class="Keyword">import</a> <a id="218" href="Prelude.Sets.html" class="Module">Prelude.Sets</a> <a id="231" class="Symbol">as</a> <a id="234" class="Module">Set</a> <a id="238" class="Keyword">hiding</a> <a id="245" class="Symbol">(</a><a id="246" href="Prelude.Sets.Interface.html#671" class="Function Operator">_♯_</a><a id="249" class="Symbol">)</a>
<a id="251" class="Keyword">open</a> <a id="256" class="Keyword">import</a> <a id="263" href="Prelude.Ord.html" class="Module">Prelude.Ord</a>
<a id="275" class="Keyword">open</a> <a id="280" class="Keyword">import</a> <a id="287" href="Prelude.Functor.html" class="Module">Prelude.Functor</a>

<a id="304" class="Keyword">open</a> <a id="309" class="Keyword">import</a> <a id="316" href="UTxO.html" class="Module">UTxO</a>
<a id="321" class="Keyword">open</a> <a id="326" class="Keyword">import</a> <a id="333" href="Ledger.html" class="Module">Ledger</a>
<a id="340" class="Keyword">open</a> <a id="345" class="Keyword">import</a> <a id="352" href="HoareLogic.html" class="Module">HoareLogic</a>

<a id="364" class="Comment">-- Which addresses does a ledger modify?</a>
<a id="mod"></a><a id="405" href="SL.html#405" class="Function">mod</a> <a id="409" class="Symbol">:</a> <a id="411" href="UTxO.html#383" class="Function">Address</a> <a id="419" class="Symbol">→</a> <a id="421" href="UTxO.html#1732" class="Function">L</a> <a id="423" class="Symbol">→</a> <a id="425" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="429" href="SL.html#405" class="Function">mod</a> <a id="433" href="SL.html#433" class="Bound">A</a> <a id="435" class="Symbol">=</a> <a id="437" href="Data.List.Relation.Unary.Any.html#1156" class="Datatype">Any</a> <a id="441" class="Symbol">λ</a> <a id="443" href="SL.html#443" class="Bound">tx</a> <a id="446" class="Symbol">→</a> <a id="448" href="SL.html#433" class="Bound">A</a> <a id="450" href="Data.List.Membership.Setoid.html#887" class="Function Operator">∈</a> <a id="452" class="Symbol">(</a><a id="453" href="UTxO.html#773" class="Field">address</a> <a id="461" href="Prelude.Functor.html#299" class="Field Operator">&lt;$&gt;</a> <a id="465" href="SL.html#443" class="Bound">tx</a> <a id="468" class="Symbol">.</a><a id="469" href="UTxO.html#1495" class="Field">outputs</a><a id="476" class="Symbol">)</a>

<a id="479" class="Comment">-- Which addresses does an assertion refer to?</a>
<a id="addr"></a><a id="526" href="SL.html#526" class="Function">addr</a> <a id="531" class="Symbol">:</a> <a id="533" href="UTxO.html#383" class="Function">Address</a> <a id="541" class="Symbol">→</a> <a id="543" href="HoareLogic.html#441" class="Datatype">Assertion</a> <a id="553" class="Symbol">→</a> <a id="555" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="559" href="SL.html#526" class="Function">addr</a> <a id="564" href="SL.html#564" class="Bound">A</a> <a id="566" href="HoareLogic.html#466" class="InductiveConstructor">`emp</a>     <a id="575" class="Symbol">=</a> <a id="577" href="Data.Empty.html#526" class="Datatype">⊥</a>
<a id="579" href="SL.html#526" class="Function">addr</a> <a id="584" href="SL.html#584" class="Bound">A</a> <a id="586" class="Symbol">(</a><a id="587" href="SL.html#587" class="Bound">B</a> <a id="589" href="HoareLogic.html#542" class="InductiveConstructor Operator">`↦</a> <a id="592" class="Symbol">_)</a> <a id="595" class="Symbol">=</a> <a id="597" href="SL.html#584" class="Bound">A</a> <a id="599" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="601" href="SL.html#587" class="Bound">B</a>
<a id="603" href="SL.html#526" class="Function">addr</a> <a id="608" href="SL.html#608" class="Bound">A</a> <a id="610" class="Symbol">(</a><a id="611" href="SL.html#611" class="Bound">P</a> <a id="613" href="HoareLogic.html#630" class="InductiveConstructor Operator">`∗</a> <a id="616" href="SL.html#616" class="Bound">Q</a><a id="617" class="Symbol">)</a> <a id="619" class="Symbol">=</a> <a id="621" href="SL.html#526" class="Function">addr</a> <a id="626" href="SL.html#608" class="Bound">A</a> <a id="628" href="SL.html#611" class="Bound">P</a> <a id="630" href="Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="632" href="SL.html#526" class="Function">addr</a> <a id="637" href="SL.html#608" class="Bound">A</a> <a id="639" href="SL.html#616" class="Bound">Q</a>
<a id="641" href="SL.html#526" class="Function">addr</a> <a id="646" href="SL.html#646" class="Bound">A</a> <a id="648" class="Symbol">(</a><a id="649" href="SL.html#649" class="Bound">P</a> <a id="651" href="HoareLogic.html#701" class="InductiveConstructor Operator">`∘⟦</a> <a id="655" class="Symbol">_</a> <a id="657" href="HoareLogic.html#701" class="InductiveConstructor Operator">⟧</a><a id="658" class="Symbol">)</a> <a id="660" class="Symbol">=</a> <a id="662" href="SL.html#526" class="Function">addr</a> <a id="667" href="SL.html#646" class="Bound">A</a> <a id="669" href="SL.html#649" class="Bound">P</a>

<a id="672" class="Comment">-- Define disjointness between ledgers/states/formulas as disjointness of the participant set they refer to.</a>
<a id="781" class="Keyword">record</a> <a id="_//_"></a><a id="788" href="SL.html#788" class="Record Operator">_//_</a> <a id="793" class="Symbol">(</a><a id="794" href="SL.html#794" class="Bound">A</a> <a id="796" class="Symbol">:</a> <a id="798" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="802" href="Prelude.Init.html#194" class="Generalizable">ℓ</a><a id="803" class="Symbol">)</a> <a id="805" class="Symbol">(</a><a id="806" href="SL.html#806" class="Bound">B</a> <a id="808" class="Symbol">:</a> <a id="810" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="814" href="Prelude.Init.html#196" class="Generalizable">ℓ′</a><a id="816" class="Symbol">)</a> <a id="818" class="Symbol">:</a> <a id="820" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="824" class="Symbol">(</a><a id="825" href="SL.html#802" class="Bound">ℓ</a> <a id="827" href="Agda.Primitive.html#810" class="Primitive Operator">⊔ₗ</a> <a id="830" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="835" href="SL.html#814" class="Bound">ℓ′</a><a id="837" class="Symbol">)</a> <a id="839" class="Keyword">where</a>
  <a id="847" class="Keyword">field</a> <a id="_//_._♯_"></a><a id="853" href="SL.html#853" class="Field Operator">_♯_</a> <a id="857" class="Symbol">:</a> <a id="859" href="SL.html#794" class="Bound">A</a> <a id="861" class="Symbol">→</a> <a id="863" href="SL.html#806" class="Bound">B</a> <a id="865" class="Symbol">→</a> <a id="867" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="871" class="Keyword">open</a> <a id="876" href="SL.html#788" class="Module Operator">_//_</a> <a id="881" class="Symbol">⦃...⦄</a> <a id="887" class="Keyword">public</a>

<a id="895" class="Keyword">instance</a>
  <a id="Disjoint-SS"></a><a id="906" href="SL.html#906" class="Function">Disjoint-SS</a> <a id="918" class="Symbol">:</a> <a id="920" href="UTxO.html#1964" class="Function">S</a> <a id="922" href="SL.html#788" class="Record Operator">//</a> <a id="925" href="UTxO.html#1964" class="Function">S</a>
  <a id="929" href="SL.html#906" class="Function">Disjoint-SS</a> <a id="941" class="Symbol">.</a><a id="942" href="SL.html#853" class="Field Operator">_♯_</a> <a id="946" class="Symbol">=</a> <a id="948" href="Prelude.Sets.Interface.html#671" class="Function Operator">Set._♯_</a>

  <a id="Disjoint-LS"></a><a id="959" href="SL.html#959" class="Function">Disjoint-LS</a> <a id="971" class="Symbol">:</a> <a id="973" href="UTxO.html#1732" class="Function">L</a> <a id="975" href="SL.html#788" class="Record Operator">//</a> <a id="978" href="UTxO.html#1964" class="Function">S</a>
  <a id="982" href="SL.html#959" class="Function">Disjoint-LS</a> <a id="994" class="Symbol">.</a><a id="995" href="SL.html#853" class="Field Operator">_♯_</a> <a id="999" href="SL.html#999" class="Bound">l</a> <a id="1001" href="SL.html#1001" class="Bound">s</a> <a id="1003" class="Symbol">=</a> <a id="1005" class="Symbol">∀</a> <a id="1007" href="SL.html#1007" class="Bound">A</a> <a id="1009" class="Symbol">→</a> <a id="1011" href="SL.html#405" class="Function">mod</a> <a id="1015" href="SL.html#1007" class="Bound">A</a> <a id="1017" href="SL.html#999" class="Bound">l</a> <a id="1019" class="Symbol">→</a> <a id="1021" href="Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="1023" href="Data.Product.html#1369" class="Function">∃</a> <a id="1025" class="Symbol">λ</a> <a id="1027" href="SL.html#1027" class="Bound">utxo</a> <a id="1032" class="Symbol">→</a> <a id="1034" class="Symbol">(</a><a id="1035" href="SL.html#1027" class="Bound">utxo</a> <a id="1040" class="Symbol">.</a><a id="1041" href="UTxO.html#1806" class="Field">UTXO.out</a> <a id="1050" class="Symbol">.</a><a id="1051" href="UTxO.html#773" class="Field">address</a> <a id="1059" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1061" href="SL.html#1007" class="Bound">A</a><a id="1062" class="Symbol">)</a> <a id="1064" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="1066" class="Symbol">(</a><a id="1067" href="SL.html#1027" class="Bound">utxo</a> <a id="1072" href="Prelude.Sets.Interface.html#473" class="Function Operator">∈ˢ</a> <a id="1075" href="SL.html#1001" class="Bound">s</a><a id="1076" class="Symbol">)</a>

  <a id="Disjoint-SL"></a><a id="1081" href="SL.html#1081" class="Function">Disjoint-SL</a> <a id="1093" class="Symbol">:</a> <a id="1095" href="UTxO.html#1964" class="Function">S</a> <a id="1097" href="SL.html#788" class="Record Operator">//</a> <a id="1100" href="UTxO.html#1732" class="Function">L</a>
  <a id="1104" href="SL.html#1081" class="Function">Disjoint-SL</a> <a id="1116" class="Symbol">.</a><a id="1117" href="SL.html#853" class="Field Operator">_♯_</a> <a id="1121" href="SL.html#1121" class="Bound">s</a> <a id="1123" href="SL.html#1123" class="Bound">l</a> <a id="1125" class="Symbol">=</a> <a id="1127" class="Symbol">∀</a> <a id="1129" href="SL.html#1129" class="Bound">A</a> <a id="1131" class="Symbol">→</a> <a id="1133" class="Symbol">(</a><a id="1134" href="Data.Product.html#1369" class="Function">∃</a> <a id="1136" class="Symbol">λ</a> <a id="1138" href="SL.html#1138" class="Bound">utxo</a> <a id="1143" class="Symbol">→</a> <a id="1145" class="Symbol">(</a><a id="1146" href="SL.html#1138" class="Bound">utxo</a> <a id="1151" class="Symbol">.</a><a id="1152" href="UTxO.html#1806" class="Field">UTXO.out</a> <a id="1161" class="Symbol">.</a><a id="1162" href="UTxO.html#773" class="Field">address</a> <a id="1170" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1172" href="SL.html#1129" class="Bound">A</a><a id="1173" class="Symbol">)</a> <a id="1175" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="1177" class="Symbol">(</a><a id="1178" href="SL.html#1138" class="Bound">utxo</a> <a id="1183" href="Prelude.Sets.Interface.html#473" class="Function Operator">∈ˢ</a> <a id="1186" href="SL.html#1121" class="Bound">s</a><a id="1187" class="Symbol">))</a> <a id="1190" class="Symbol">→</a> <a id="1192" href="Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="1194" href="SL.html#405" class="Function">mod</a> <a id="1198" href="SL.html#1129" class="Bound">A</a> <a id="1200" href="SL.html#1123" class="Bound">l</a>

  <a id="Disjoint-LA"></a><a id="1205" href="SL.html#1205" class="Function">Disjoint-LA</a> <a id="1217" class="Symbol">:</a> <a id="1219" href="UTxO.html#1732" class="Function">L</a> <a id="1221" href="SL.html#788" class="Record Operator">//</a> <a id="1224" href="HoareLogic.html#441" class="Datatype">Assertion</a>
  <a id="1236" href="SL.html#1205" class="Function">Disjoint-LA</a> <a id="1248" class="Symbol">.</a><a id="1249" href="SL.html#853" class="Field Operator">_♯_</a> <a id="1253" href="SL.html#1253" class="Bound">l</a> <a id="1255" href="SL.html#1255" class="Bound">P</a> <a id="1257" class="Symbol">=</a> <a id="1259" class="Symbol">∀</a> <a id="1261" href="SL.html#1261" class="Bound">A</a> <a id="1263" class="Symbol">→</a> <a id="1265" href="SL.html#405" class="Function">mod</a> <a id="1269" href="SL.html#1261" class="Bound">A</a> <a id="1271" href="SL.html#1253" class="Bound">l</a> <a id="1273" class="Symbol">→</a> <a id="1275" href="Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="1277" href="SL.html#526" class="Function">addr</a> <a id="1282" href="SL.html#1261" class="Bound">A</a> <a id="1284" href="SL.html#1255" class="Bound">P</a>

<a id="1287" class="Comment">-- ** Utility lemmas about separation.</a>

<a id="1327" class="Comment">-- ∈ᵈ-∪ : ⟨ s₁ ⊎ s₂ ⟩≡ s → A ∈ᵈ s → A ∈ᵈ s₁ ⊎ A ∈ᵈ s₂</a>
<a id="1381" class="Comment">-- ∈ᵈ-∪ {s₁}{s₂}{s}{A} (s₁♯s₂ , p) A∈ = ∈ᵈ-∪⁻ _ _ _ (∈ᵈ-cong (≈-sym p) A∈)</a>

<a id="1457" class="Comment">-- ∉ᵈ-∪ : ⟨ s₁ ⊎ s₂ ⟩≡ s → A ∉ᵈ s → A ∉ᵈ s₁ × A ∉ᵈ s₂</a>
<a id="1511" class="Comment">-- ∉ᵈ-∪ {s₁}{s₂}{s}{A} (s₁♯s₂ , p) A∉ = A∉ ∘ ∈ᵈ-cong p ∘ ∈ᵈ-∪⁺ˡ _ _ _ , A∉ ∘ ∈ᵈ-cong p ∘ ∈ᵈ-∪⁺ʳ _ _ _</a>

<a id="1614" class="Comment">-- ∈⇒addr : A ∈ᵈ s → P ∙ s → addr A P</a>
<a id="1652" class="Comment">-- ∈⇒addr {A}{s}{P = `emp} A∈ Ps = ⊥-elim $ Ps A A∈</a>
<a id="1704" class="Comment">-- ∈⇒addr {A}{s}{P = B `↦ v} A∈ Ps with A ≟ B</a>
<a id="1750" class="Comment">-- ... | yes A≡B = A≡B</a>
<a id="1773" class="Comment">-- ... | no  A≢B = ⊥-elim $ proj₂ Ps A A≢B A∈</a>
<a id="1819" class="Comment">-- ∈⇒addr {A}{s}{P = P `∗ Q} A∈ (s₁ , s₂ , ≡s , Ps₁ , Qs₂)</a>
<a id="1878" class="Comment">--   with ∈ᵈ-∪ ≡s A∈</a>
<a id="1899" class="Comment">-- ... | inj₁ A∈₁ = inj₁ $ ∈⇒addr {P = P} A∈₁ Ps₁</a>
<a id="1949" class="Comment">-- ... | inj₂ A∈₂ = inj₂ $ ∈⇒addr {P = Q} A∈₂ Qs₂</a>
<a id="1999" class="Comment">-- ∈⇒addr {A}{s}{P = P `∘⟦ l ⟧} A∈ Ps = ∈⇒addr {P = P} (⟦⟧ₗ-mono {l} s A A∈) Ps</a>

<a id="2080" class="Comment">-- ∉⇒¬addr : A ∉ᵈ s → P ∙ s → ¬ addr A P</a>
<a id="2121" class="Comment">-- ∉⇒¬addr {A}{s}{P = `emp} A∉ Ps ()</a>
<a id="2158" class="Comment">-- ∉⇒¬addr {A}{s}{P = .A `↦ _} A∉ (Ps , _) refl = A∉ $ ⁉⇒∈ᵈ (subst Is-just (sym Ps) auto)</a>
<a id="2248" class="Comment">-- ∉⇒¬addr {A}{s}{P = P `∗ Q} A∉ (s₁ , s₂ , ≡s , Ps₁ , Qs₂) A∈</a>
<a id="2311" class="Comment">--   with A∉ˡ , A∉ʳ ← ∉ᵈ-∪ ≡s A∉</a>
<a id="2344" class="Comment">--   with A∈</a>
<a id="2357" class="Comment">-- ... | inj₁ A∈ˡ = ∉⇒¬addr {P = P} A∉ˡ Ps₁ A∈ˡ</a>
<a id="2405" class="Comment">-- ... | inj₂ A∈ʳ = ∉⇒¬addr {P = Q} A∉ʳ Qs₂ A∈ʳ</a>
<a id="2453" class="Comment">-- ∉⇒¬addr {A}{s}{P = P `∘⟦ l ⟧} A∉ Ps A∈ = ∉⇒¬addr {P = P} (∉-⟦⟧ₗ {l = l} A∉) Ps A∈</a>

<a id="♯-skip"></a><a id="2539" href="SL.html#2539" class="Function">♯-skip</a> <a id="2546" class="Symbol">:</a> <a id="2548" class="Symbol">(</a><a id="2549" href="Ledger.html#1111" class="Generalizable">t</a> <a id="2551" class="InductiveConstructor Operator">∷</a> <a id="2553" href="Ledger.html#1126" class="Generalizable">l</a><a id="2554" class="Symbol">)</a> <a id="2556" href="SL.html#853" class="Field Operator">♯</a> <a id="2558" href="HoareLogic.html#865" class="Generalizable">P</a> <a id="2560" class="Symbol">→</a> <a id="2562" href="Ledger.html#1126" class="Generalizable">l</a> <a id="2564" href="SL.html#853" class="Field Operator">♯</a> <a id="2566" href="HoareLogic.html#865" class="Generalizable">P</a>
<a id="2568" href="SL.html#2539" class="Function">♯-skip</a> <a id="2575" href="SL.html#2575" class="Bound">p</a> <a id="2577" href="SL.html#2577" class="Bound">A</a> <a id="2579" class="Symbol">=</a> <a id="2581" href="SL.html#2575" class="Bound">p</a> <a id="2583" href="SL.html#2577" class="Bound">A</a> <a id="2585" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="2587" href="Data.List.Relation.Unary.Any.html#1272" class="InductiveConstructor">there</a>

<a id="2594" class="Comment">-- ♯⇒♯ : l ♯ s → s ♯ l</a>
<a id="2617" class="Comment">-- ♯⇒♯ {s = s} p A A∈ A∈l = p _ A∈l A∈</a>

<a id="♯♯⇒♯"></a><a id="2657" href="SL.html#2657" class="Function">♯♯⇒♯</a> <a id="2662" class="Symbol">:</a> <a id="2664" href="Ledger.html#1126" class="Generalizable">l</a> <a id="2666" href="SL.html#853" class="Field Operator">♯</a> <a id="2668" href="HoareLogic.html#887" class="Generalizable">R</a> <a id="2670" class="Symbol">→</a> <a id="2672" href="HoareLogic.html#887" class="Generalizable">R</a> <a id="2674" href="HoareLogic.html#1814" class="Function Operator">∙</a> <a id="2676" href="Ledger.html#1091" class="Generalizable">s</a> <a id="2678" class="Symbol">→</a> <a id="2680" href="Ledger.html#1126" class="Generalizable">l</a> <a id="2682" href="SL.html#853" class="Field Operator">♯</a> <a id="2684" href="Ledger.html#1091" class="Generalizable">s</a>
<a id="2686" href="SL.html#2657" class="Function">♯♯⇒♯</a> <a id="2691" class="Symbol">{</a><a id="2692" href="SL.html#2692" class="Bound">l</a><a id="2693" class="Symbol">}</a> <a id="2695" class="Symbol">{</a><a id="2696" href="HoareLogic.html#466" class="InductiveConstructor">`emp</a><a id="2700" class="Symbol">}</a> <a id="2702" class="Symbol">{</a><a id="2703" href="SL.html#2703" class="Bound">s</a><a id="2704" class="Symbol">}</a> <a id="2706" href="SL.html#2706" class="Bound">l♯R</a> <a id="2710" href="SL.html#2710" class="Bound">s∅</a> <a id="2713" class="Symbol">=</a> <a id="2715" class="Symbol">λ</a> <a id="2717" href="SL.html#2717" class="Bound">_</a> <a id="2719" href="SL.html#2719" class="Bound">_</a> <a id="2721" class="Symbol">(_</a> <a id="2724" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2726" class="Symbol">_</a> <a id="2728" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2730" href="SL.html#2730" class="Bound">utxo∈</a><a id="2735" class="Symbol">)</a> <a id="2737" class="Symbol">→</a> <a id="2739" href="SL.html#2710" class="Bound">s∅</a> <a id="2742" class="Symbol">_</a> <a id="2744" href="SL.html#2730" class="Bound">utxo∈</a>
<a id="2750" href="SL.html#2657" class="Function">♯♯⇒♯</a> <a id="2755" class="Symbol">{</a><a id="2756" href="SL.html#2756" class="Bound">l</a><a id="2757" class="Symbol">}</a> <a id="2759" class="Symbol">{</a><a id="2760" href="SL.html#2760" class="Bound">A</a> <a id="2762" href="HoareLogic.html#542" class="InductiveConstructor Operator">`↦</a> <a id="2765" href="SL.html#2765" class="Bound">v</a><a id="2766" class="Symbol">}</a> <a id="2768" class="Symbol">{</a><a id="2769" href="SL.html#2769" class="Bound">s</a><a id="2770" class="Symbol">}</a> <a id="2772" href="SL.html#2772" class="Bound">l♯R</a> <a id="2776" href="SL.html#2776" class="Bound">Rs</a> <a id="2779" class="Symbol">=</a> <a id="2781" class="Hole">{!!}</a>
<a id="2786" href="SL.html#2657" class="Function">♯♯⇒♯</a> <a id="2791" class="Symbol">{</a><a id="2792" href="SL.html#2792" class="Bound">l</a><a id="2793" class="Symbol">}</a> <a id="2795" class="Symbol">{</a><a id="2796" href="SL.html#2796" class="Bound">R</a> <a id="2798" href="HoareLogic.html#630" class="InductiveConstructor Operator">`∗</a> <a id="2801" href="SL.html#2801" class="Bound">Q</a><a id="2802" class="Symbol">}</a> <a id="2804" class="Symbol">{</a><a id="2805" href="SL.html#2805" class="Bound">s</a><a id="2806" class="Symbol">}</a> <a id="2808" href="SL.html#2808" class="Bound">l♯R</a> <a id="2812" href="SL.html#2812" class="Bound">Rs</a> <a id="2815" class="Symbol">=</a> <a id="2817" class="Hole">{!!}</a>
<a id="2822" href="SL.html#2657" class="Function">♯♯⇒♯</a> <a id="2827" class="Symbol">{_}</a> <a id="2831" class="Symbol">{</a><a id="2832" href="SL.html#2832" class="Bound">R</a> <a id="2834" href="HoareLogic.html#701" class="InductiveConstructor Operator">`∘⟦</a> <a id="2838" href="SL.html#2838" class="Bound">l</a> <a id="2840" href="HoareLogic.html#701" class="InductiveConstructor Operator">⟧</a><a id="2841" class="Symbol">}</a> <a id="2843" class="Symbol">{</a><a id="2844" href="SL.html#2844" class="Bound">s</a><a id="2845" class="Symbol">}</a> <a id="2847" href="SL.html#2847" class="Bound">l♯R</a> <a id="2851" href="SL.html#2851" class="Bound">Rs</a> <a id="2854" class="Symbol">=</a> <a id="2856" class="Hole">{!!}</a>

<a id="2862" class="Comment">-- ♯♯⇒♯ {l}{`emp}{s} l♯R s∅ A A∈ = s∅ A</a>
<a id="2902" class="Comment">-- ♯♯⇒♯ {l}{B `↦ v}{s} l♯R (_ , B↦) A A∈ A∈′</a>
<a id="2947" class="Comment">--   with A ≟ B</a>
<a id="2963" class="Comment">-- ... | yes refl = l♯R A A∈ refl</a>
<a id="2997" class="Comment">-- ... | no  A≢B  = B↦ A A≢B A∈′</a>
<a id="3030" class="Comment">-- ♯♯⇒♯ {l}{R `∗ Q}{s} l♯R (s₁ , s₂ , ≡s , Rs₁ , Qs₂) A A∈</a>
<a id="3089" class="Comment">--   with s₁ ⁉ A | inspect (s₁ ⁉_) A | s₂ ⁉ A | inspect (s₂ ⁉_) A</a>
<a id="3155" class="Comment">-- ... | just _  | ≡[ s₁≡ ] | _       | _</a>
<a id="3197" class="Comment">--     = ⊥-elim $ l♯R A A∈ $ inj₁ $ ∈⇒addr {A}{s₁}{R} (⁉⇒∈ᵈ $ subst Is-just (sym s₁≡) auto) Rs₁</a>
<a id="3293" class="Comment">-- ... | _       | _        | just _  | ≡[ s₂≡ ]</a>
<a id="3342" class="Comment">--     = ⊥-elim $ l♯R A A∈ $ inj₂ $ ∈⇒addr {A}{s₂}{Q} (⁉⇒∈ᵈ $ subst M.Is-just (sym s₂≡) auto) Qs₂</a>
<a id="3440" class="Comment">-- ... | nothing | ≡[ s₁≡ ] | nothing | ≡[ s₂≡ ]</a>
<a id="3489" class="Comment">--   = ∉-splits ≡s (⊥-elim ∘ ⁉⇒∉ᵈ (subst Is-nothing (sym s₁≡) auto))</a>
<a id="3558" class="Comment">--                 (⊥-elim ∘ ⁉⇒∉ᵈ (subst Is-nothing (sym s₂≡) auto))</a>
<a id="3627" class="Comment">-- ♯♯⇒♯ {_}{R `∘⟦ l ⟧}{s} l♯R Rs A A∈ = ¬A∈</a>
<a id="3671" class="Comment">--   where</a>
<a id="3682" class="Comment">--     A∉ : A ∉ᵈ ⟦ l ⟧ s</a>
<a id="3707" class="Comment">--     A∉ = ♯♯⇒♯ {R = R} {s = ⟦ l ⟧ s} l♯R Rs A A∈</a>

<a id="3759" class="Comment">--     ¬A∈ : A ∉ᵈ s</a>
<a id="3779" class="Comment">--     ¬A∈ = A∉ ∘ ⟦⟧ₗ-mono {l} s A</a>

<a id="3815" class="Comment">-- Helper lemma for [FRAME]: pushing ⟦ l ⟧ inside the partition.</a>
<a id="frame-helper"></a><a id="3880" href="SL.html#3880" class="Function">frame-helper</a> <a id="3893" class="Symbol">:</a>
    <a id="3899" href="Ledger.html#1126" class="Generalizable">l</a> <a id="3901" href="SL.html#853" class="Field Operator">♯</a> <a id="3903" href="HoareLogic.html#887" class="Generalizable">R</a>
  <a id="3907" class="Symbol">→</a> <a id="3909" href="HoareLogic.html#887" class="Generalizable">R</a> <a id="3911" href="HoareLogic.html#1814" class="Function Operator">∙</a> <a id="3913" href="Ledger.html#1102" class="Generalizable">s₂</a>
  <a id="3918" class="Symbol">→</a> <a id="3920" href="HoareLogic.html#902" class="Function Operator">⟨</a> <a id="3922" href="Ledger.html#1099" class="Generalizable">s₁</a> <a id="3925" href="HoareLogic.html#902" class="Function Operator">⊎</a> <a id="3927" href="Ledger.html#1102" class="Generalizable">s₂</a> <a id="3930" href="HoareLogic.html#902" class="Function Operator">⟩≡</a> <a id="3933" href="Ledger.html#1091" class="Generalizable">s</a>
    <a id="3939" class="Comment">-----------------------</a>
  <a id="3965" class="Symbol">→</a> <a id="3967" href="HoareLogic.html#902" class="Function Operator">⟨</a> <a id="3969" href="Ledger.html#479" class="Field Operator">⟦</a> <a id="3971" href="Ledger.html#1126" class="Generalizable">l</a> <a id="3973" href="Ledger.html#479" class="Field Operator">⟧</a> <a id="3975" href="Ledger.html#1099" class="Generalizable">s₁</a> <a id="3978" href="HoareLogic.html#902" class="Function Operator">⊎</a> <a id="3980" href="Ledger.html#1102" class="Generalizable">s₂</a> <a id="3983" href="HoareLogic.html#902" class="Function Operator">⟩≡</a> <a id="3986" href="Ledger.html#479" class="Field Operator">⟦</a> <a id="3988" href="Ledger.html#1126" class="Generalizable">l</a> <a id="3990" href="Ledger.html#479" class="Field Operator">⟧</a> <a id="3992" href="Ledger.html#1091" class="Generalizable">s</a>
<a id="3994" href="SL.html#3880" class="Function">frame-helper</a> <a id="4007" class="Symbol">{</a><a id="4008" class="Argument">l</a> <a id="4010" class="Symbol">=</a> <a id="4012" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4014" class="Symbol">}</a> <a id="4016" class="Symbol">_</a> <a id="4018" class="Symbol">_</a> <a id="4020" href="SL.html#4020" class="Bound">p</a> <a id="4022" class="Symbol">=</a> <a id="4024" href="SL.html#4020" class="Bound">p</a>
<a id="4026" href="SL.html#3880" class="Function">frame-helper</a> <a id="4039" class="Symbol">{</a><a id="4040" class="Argument">l</a> <a id="4042" class="Symbol">=</a> <a id="4044" href="SL.html#4044" class="Bound">tx</a> <a id="4047" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4049" href="SL.html#4049" class="Bound">l</a><a id="4050" class="Symbol">}{</a><a id="4052" href="SL.html#4052" class="Bound">R</a><a id="4053" class="Symbol">}{</a><a id="4055" href="SL.html#4055" class="Bound">s₂</a><a id="4057" class="Symbol">}{</a><a id="4059" href="SL.html#4059" class="Bound">s₁</a><a id="4061" class="Symbol">}{</a><a id="4063" href="SL.html#4063" class="Bound">s</a><a id="4064" class="Symbol">}</a> <a id="4066" href="SL.html#4066" class="Bound">l♯R</a> <a id="4070" href="SL.html#4070" class="Bound">Rs₂</a> <a id="4074" class="Symbol">(</a><a id="4075" href="SL.html#4075" class="Bound">s₁♯s₂</a> <a id="4081" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4083" href="SL.html#4083" class="Bound">≡s</a><a id="4085" class="Symbol">)</a> <a id="4087" class="Symbol">=</a>
  <a id="4091" href="SL.html#3880" class="Function">frame-helper</a> <a id="4104" class="Symbol">{</a><a id="4105" href="SL.html#4049" class="Bound">l</a><a id="4106" class="Symbol">}{</a><a id="4108" href="SL.html#4052" class="Bound">R</a><a id="4109" class="Symbol">}{</a><a id="4111" href="SL.html#4055" class="Bound">s₂</a><a id="4113" class="Symbol">}{</a><a id="4115" href="Ledger.html#479" class="Field Operator">⟦</a> <a id="4117" href="SL.html#4044" class="Bound">tx</a> <a id="4120" href="Ledger.html#479" class="Field Operator">⟧</a> <a id="4122" href="SL.html#4059" class="Bound">s₁</a><a id="4124" class="Symbol">}{</a><a id="4126" href="Ledger.html#479" class="Field Operator">⟦</a> <a id="4128" href="SL.html#4044" class="Bound">tx</a> <a id="4131" href="Ledger.html#479" class="Field Operator">⟧</a> <a id="4133" href="SL.html#4063" class="Bound">s</a><a id="4134" class="Symbol">}</a> <a id="4136" class="Symbol">(</a><a id="4137" href="SL.html#2539" class="Function">♯-skip</a> <a id="4144" class="Symbol">{</a><a id="4145" class="Argument">P</a> <a id="4147" class="Symbol">=</a> <a id="4149" href="SL.html#4052" class="Bound">R</a><a id="4150" class="Symbol">}</a> <a id="4152" href="SL.html#4066" class="Bound">l♯R</a><a id="4155" class="Symbol">)</a> <a id="4157" href="SL.html#4070" class="Bound">Rs₂</a> <a id="4161" href="SL.html#4312" class="Function">p′</a>
  <a id="4166" class="Keyword">where</a>
    <a id="4176" href="SL.html#4176" class="Function">p₁</a> <a id="4179" class="Symbol">:</a> <a id="4181" class="Symbol">(</a><a id="4182" href="Ledger.html#479" class="Field Operator">⟦</a> <a id="4184" href="SL.html#4044" class="Bound">tx</a> <a id="4187" href="Ledger.html#479" class="Field Operator">⟧</a> <a id="4189" href="SL.html#4059" class="Bound">s₁</a><a id="4191" class="Symbol">)</a> <a id="4193" href="SL.html#853" class="Field Operator">♯</a> <a id="4195" href="SL.html#4055" class="Bound">s₂</a>
    <a id="4202" href="SL.html#4176" class="Function">p₁</a> <a id="4205" class="Symbol">=</a> <a id="4207" class="Hole">{!!}</a>
    <a id="4216" class="Comment">-- p₁ = transfer-helper s₁♯s₂ B∉₂</a>

    <a id="4255" href="SL.html#4255" class="Function">p₂</a> <a id="4258" class="Symbol">:</a> <a id="4260" class="Symbol">((</a><a id="4262" href="Ledger.html#479" class="Field Operator">⟦</a> <a id="4264" href="SL.html#4044" class="Bound">tx</a> <a id="4267" href="Ledger.html#479" class="Field Operator">⟧</a> <a id="4269" href="SL.html#4059" class="Bound">s₁</a><a id="4271" class="Symbol">)</a> <a id="4273" href="Prelude.Sets.Interface.html#504" class="Function Operator">∪</a> <a id="4275" href="SL.html#4055" class="Bound">s₂</a><a id="4277" class="Symbol">)</a> <a id="4279" href="Prelude.Sets.html#459" class="Function Operator">≈ˢ</a> <a id="4282" class="Symbol">(</a><a id="4283" href="Ledger.html#479" class="Field Operator">⟦</a> <a id="4285" href="SL.html#4044" class="Bound">tx</a> <a id="4288" href="Ledger.html#479" class="Field Operator">⟧</a> <a id="4290" href="SL.html#4063" class="Bound">s</a><a id="4291" class="Symbol">)</a>
    <a id="4297" href="SL.html#4255" class="Function">p₂</a> <a id="4300" class="Symbol">=</a> <a id="4302" class="Hole">{!!}</a>

    <a id="4312" href="SL.html#4312" class="Function">p′</a> <a id="4315" class="Symbol">:</a> <a id="4317" href="HoareLogic.html#902" class="Function Operator">⟨</a> <a id="4319" href="Ledger.html#479" class="Field Operator">⟦</a> <a id="4321" href="SL.html#4044" class="Bound">tx</a> <a id="4324" href="Ledger.html#479" class="Field Operator">⟧</a> <a id="4326" href="SL.html#4059" class="Bound">s₁</a> <a id="4329" href="HoareLogic.html#902" class="Function Operator">⊎</a> <a id="4331" href="SL.html#4055" class="Bound">s₂</a> <a id="4334" href="HoareLogic.html#902" class="Function Operator">⟩≡</a> <a id="4337" href="Ledger.html#479" class="Field Operator">⟦</a> <a id="4339" href="SL.html#4044" class="Bound">tx</a> <a id="4342" href="Ledger.html#479" class="Field Operator">⟧</a> <a id="4344" href="SL.html#4063" class="Bound">s</a>
    <a id="4350" href="SL.html#4312" class="Function">p′</a> <a id="4353" class="Symbol">=</a> <a id="4355" href="SL.html#4176" class="Function">p₁</a> <a id="4358" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4360" href="SL.html#4255" class="Function">p₂</a>


<a id="4365" class="Comment">{-
frame-helper {l = l₀@(A —→⟨ v ⟩ B ∷ l)}{R}{s₂}{s₁}{s} l♯R Rs₂ (s₁♯s₂ , ≡s) =
  frame-helper {l}{R}{s₂}{run [ A ∣ v ↦ B ] s₁} {run [ A ∣ v ↦ B ] s} (♯-skip {P = R} l♯R) Rs₂ p′
  where
    l♯s₂ : l₀ ♯ s₂
    l♯s₂ = ♯♯⇒♯ {R = R} l♯R Rs₂

    A∉₂ : A ∉ᵈ s₂
    A∉₂ = l♯s₂ A $ here (here refl)

    B∉₂ : B ∉ᵈ s₂
    B∉₂ = l♯s₂ B $ here (there (here refl))

    p₁ : (run [ A ∣ v ↦ B ] s₁) Map.♯ s₂
    p₁ = transfer-helper s₁♯s₂ B∉₂

    ∉⇒≢ : ∀ k → k ∈ᵈ s₂ → (k ≢ A) × (k ≢ B)
    ∉⇒≢ k k∈ = k≢A , k≢B
      where
        k∉ : ¬ mod k l₀
        k∉ = ♯⇒♯ l♯s₂ k k∈

        k≢A : k ≢ A
        k≢A refl = ⊥-elim $ k∉ (here (here refl))

        k≢B : k ≢ B
        k≢B refl = ⊥-elim $ k∉ (here (there (here refl)))

    p₂ : (run [ A ∣ v ↦ B ] s₁) ∪ s₂ ≈ run [ A ∣ v ↦ B ] s
    p₂ k
      with eq ← ≡s k
      with eqᵃ ← ≡s A
      with eqᵇ ← ≡s B
      with ¿ k ∈ᵈ s₂ ¿
    ... | yes k∈
      with k≢A , k≢B ← ∉⇒≢ k k∈
      rewrite ∪-chooseᵣ p₁ k∈
            | ∪-chooseᵣ s₁♯s₂ k∈
            | drop-[∣↦] {v = v} {s = s} k k≢A k≢B
            = eq
    ... | no k∉
      rewrite ∪-chooseₗ p₁ k∉
            | ∪-chooseₗ s₁♯s₂ k∉
      with s₁ ⁉ A | inspect (s₁ ⁉_) A
         | s  ⁉ A | inspect (s  ⁉_) A
         | eqᵃ
    ... | nothing | _ | nothing | _ | _ = eq
    ... | nothing | ≡[ s₁A≡ ] | just _  | ≡[ sA≡ ] | _
        = let p = ↦-∪⁺ʳ {s₂ = s₂} $ ⁉⇒∉ᵈ (subst Is-nothing (sym s₁A≡) auto)
          in ⊥-elim $ A∉₂ $ ⁉⇒∈ᵈ $ subst Is-just (sym $ trans p (trans eqᵃ sA≡)) auto
    ... | just vᵃ | ≡[ s₁A≡ ] | nothing | _ | eqᵃ′
        = case trans (sym $ (↦-∪⁺ˡ {s₂ = s₂} s₁A≡)) eqᵃ′ of λ ()
    ... | just vᵃ  | ≡[ s₁A≡ ] | just vᵃ′ | _ | eqᵃ′
      with vᵃ ≟ vᵃ′
    ... | no neq = ⊥-elim $ neq $ M.just-injective $ trans (sym $ ↦-∪⁺ˡ {s₂ = s₂} s₁A≡) eqᵃ′
    ... | yes refl
      with s₁ ⁉ B | inspect (s₁ ⁉_) B
         | s  ⁉ B | inspect (s  ⁉_) B
         | eqᵇ
    ... | nothing | _ | nothing | _ | _
        = eq
    ... | nothing | ≡[ s₁B≡ ] | just _  | ≡[ sB≡ ] | _
        = let p = ↦-∪⁺ʳ {s₂ = s₂} $ ⁉⇒∉ᵈ (subst Is-nothing (sym s₁B≡) auto)
          in ⊥-elim $ B∉₂ $ ⁉⇒∈ᵈ $ subst Is-just (sym $ trans p (trans eqᵇ sB≡)) auto
    ... | just vᵇ | ≡[ s₁B≡ ] | nothing | _ | eqᵇ′
        = case trans (sym $ (↦-∪⁺ˡ {s₂ = s₂} s₁B≡)) eqᵇ′ of λ ()
    ... | just vᵇ  | ≡[ s₁B≡ ] | just vᵇ′ | _ | eqᵇ′
      with vᵇ ≟ vᵇ′
    ... | no neq = ⊥-elim $ neq $ M.just-injective $ trans (sym $ ↦-∪⁺ˡ {s₂ = s₂} s₁B≡) eqᵇ′
    ... | yes refl
      with v ≤? vᵃ
    ... | no  _ = eq
    ... | yes _ = ≡-cong-update $ ≡-cong-update eq

    p′ : ⟨ run [ A ∣ v ↦ B ] s₁ ⊎ s₂ ⟩≡ run [ A ∣ v ↦ B ] s
    p′ = p₁ , p₂
-}</a>

<a id="6984" class="Comment">-- The proof of the frame rule from separation logic, allowing us to prove formulas in minimal contexts</a>
<a id="7088" class="Comment">-- and then weaken our results to the desired context (assuming the rest of the context is disjoint).</a>
<a id="[FRAME]"></a><a id="7190" href="SL.html#7190" class="Function">[FRAME]</a> <a id="7198" class="Symbol">:</a> <a id="7200" class="Symbol">∀</a> <a id="7202" href="SL.html#7202" class="Bound">R</a>
  <a id="7206" class="Symbol">→</a> <a id="7208" href="Ledger.html#1126" class="Generalizable">l</a> <a id="7210" href="SL.html#853" class="Field Operator">♯</a> <a id="7212" href="SL.html#7202" class="Bound">R</a>
  <a id="7216" class="Symbol">→</a> <a id="7218" href="HoareLogic.html#1942" class="Datatype Operator">⟨</a> <a id="7220" href="HoareLogic.html#865" class="Generalizable">P</a> <a id="7222" href="HoareLogic.html#1942" class="Datatype Operator">⟩</a> <a id="7224" href="Ledger.html#1126" class="Generalizable">l</a> <a id="7226" href="HoareLogic.html#1942" class="Datatype Operator">⟨</a> <a id="7228" href="HoareLogic.html#876" class="Generalizable">Q</a> <a id="7230" href="HoareLogic.html#1942" class="Datatype Operator">⟩</a>
    <a id="7236" class="Comment">-----------------------</a>
  <a id="7262" class="Symbol">→</a> <a id="7264" href="HoareLogic.html#1942" class="Datatype Operator">⟨</a> <a id="7266" href="HoareLogic.html#865" class="Generalizable">P</a> <a id="7268" href="HoareLogic.html#630" class="InductiveConstructor Operator">`∗</a> <a id="7271" href="SL.html#7202" class="Bound">R</a> <a id="7273" href="HoareLogic.html#1942" class="Datatype Operator">⟩</a> <a id="7275" href="Ledger.html#1126" class="Generalizable">l</a> <a id="7277" href="HoareLogic.html#1942" class="Datatype Operator">⟨</a> <a id="7279" href="HoareLogic.html#876" class="Generalizable">Q</a> <a id="7281" href="HoareLogic.html#630" class="InductiveConstructor Operator">`∗</a> <a id="7284" href="SL.html#7202" class="Bound">R</a> <a id="7286" href="HoareLogic.html#1942" class="Datatype Operator">⟩</a>
<a id="7288" href="SL.html#7190" class="Function">[FRAME]</a> <a id="7296" class="Symbol">{</a><a id="7297" href="SL.html#7297" class="Bound">l</a><a id="7298" class="Symbol">}{</a><a id="7300" href="SL.html#7300" class="Bound">P</a><a id="7301" class="Symbol">}{</a><a id="7303" href="SL.html#7303" class="Bound">Q</a><a id="7304" class="Symbol">}</a> <a id="7306" href="SL.html#7306" class="Bound">R</a> <a id="7308" href="SL.html#7308" class="Bound">l♯R</a> <a id="7312" href="SL.html#7312" class="Bound">PlQ</a> <a id="7316" class="Symbol">=</a> <a id="7318" href="HoareLogic.html#2973" class="Function">denot⇒axiom</a> <a id="7330" href="SL.html#7344" class="Function">d</a>
  <a id="7334" class="Keyword">where</a>
    <a id="7344" href="SL.html#7344" class="Function">d</a> <a id="7346" class="Symbol">:</a> <a id="7348" class="Symbol">(</a><a id="7349" href="SL.html#7300" class="Bound">P</a> <a id="7351" href="HoareLogic.html#630" class="InductiveConstructor Operator">`∗</a> <a id="7354" href="SL.html#7306" class="Bound">R</a><a id="7355" class="Symbol">)</a> <a id="7357" href="HoareLogic.html#1753" class="Function Operator">`⊢</a> <a id="7360" class="Symbol">(</a><a id="7361" href="SL.html#7303" class="Bound">Q</a> <a id="7363" href="HoareLogic.html#630" class="InductiveConstructor Operator">`∗</a> <a id="7366" href="SL.html#7306" class="Bound">R</a><a id="7367" class="Symbol">)</a> <a id="7369" href="HoareLogic.html#701" class="InductiveConstructor Operator">`∘⟦</a> <a id="7373" href="SL.html#7297" class="Bound">l</a> <a id="7375" href="HoareLogic.html#701" class="InductiveConstructor Operator">⟧</a>
    <a id="7381" href="SL.html#7344" class="Function">d</a> <a id="7383" class="Symbol">{</a><a id="7384" href="SL.html#7384" class="Bound">s</a><a id="7385" class="Symbol">}</a> <a id="7387" class="Symbol">(</a><a id="7388" href="SL.html#7388" class="Bound">s₁</a> <a id="7391" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7393" href="SL.html#7393" class="Bound">s₂</a> <a id="7396" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7398" href="SL.html#7398" class="Bound">s₁♯s₂</a> <a id="7404" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7406" href="SL.html#7406" class="Bound">Ps₁</a> <a id="7410" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7412" href="SL.html#7412" class="Bound">Rs₂</a><a id="7415" class="Symbol">)</a> <a id="7417" class="Symbol">=</a> <a id="7419" href="Ledger.html#479" class="Field Operator">⟦</a> <a id="7421" href="SL.html#7297" class="Bound">l</a> <a id="7423" href="Ledger.html#479" class="Field Operator">⟧</a> <a id="7425" href="SL.html#7388" class="Bound">s₁</a> <a id="7428" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7430" href="SL.html#7393" class="Bound">s₂</a>  <a id="7434" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7436" href="SL.html#7535" class="Function">p</a> <a id="7438" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7440" href="SL.html#7471" class="Function">Qs₁′</a> <a id="7445" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7447" href="SL.html#7412" class="Bound">Rs₂</a>
      <a id="7457" class="Keyword">where</a>
        <a id="7471" href="SL.html#7471" class="Function">Qs₁′</a> <a id="7476" class="Symbol">:</a> <a id="7478" href="SL.html#7303" class="Bound">Q</a> <a id="7480" href="HoareLogic.html#1814" class="Function Operator">∙</a> <a id="7482" href="Ledger.html#479" class="Field Operator">⟦</a> <a id="7484" href="SL.html#7297" class="Bound">l</a> <a id="7486" href="Ledger.html#479" class="Field Operator">⟧</a> <a id="7488" href="SL.html#7388" class="Bound">s₁</a>
        <a id="7499" href="SL.html#7471" class="Function">Qs₁′</a> <a id="7504" class="Symbol">=</a> <a id="7506" href="HoareLogic.html#2790" class="Function">axiom⇒denot</a> <a id="7518" href="SL.html#7312" class="Bound">PlQ</a> <a id="7522" href="SL.html#7406" class="Bound">Ps₁</a>

        <a id="7535" href="SL.html#7535" class="Function">p</a> <a id="7537" class="Symbol">:</a> <a id="7539" href="HoareLogic.html#902" class="Function Operator">⟨</a> <a id="7541" href="Ledger.html#479" class="Field Operator">⟦</a> <a id="7543" href="SL.html#7297" class="Bound">l</a> <a id="7545" href="Ledger.html#479" class="Field Operator">⟧</a> <a id="7547" href="SL.html#7388" class="Bound">s₁</a> <a id="7550" href="HoareLogic.html#902" class="Function Operator">⊎</a> <a id="7552" href="SL.html#7393" class="Bound">s₂</a> <a id="7555" href="HoareLogic.html#902" class="Function Operator">⟩≡</a> <a id="7558" href="Ledger.html#479" class="Field Operator">⟦</a> <a id="7560" href="SL.html#7297" class="Bound">l</a> <a id="7562" href="Ledger.html#479" class="Field Operator">⟧</a> <a id="7564" href="SL.html#7384" class="Bound">s</a>
        <a id="7574" href="SL.html#7535" class="Function">p</a> <a id="7576" class="Symbol">=</a> <a id="7578" href="SL.html#3880" class="Function">frame-helper</a> <a id="7591" class="Symbol">{</a><a id="7592" class="Argument">R</a> <a id="7594" class="Symbol">=</a> <a id="7596" href="SL.html#7306" class="Bound">R</a><a id="7597" class="Symbol">}</a> <a id="7599" href="SL.html#7308" class="Bound">l♯R</a> <a id="7603" href="SL.html#7412" class="Bound">Rs₂</a> <a id="7607" href="SL.html#7398" class="Bound">s₁♯s₂</a>
</pre></body></html>